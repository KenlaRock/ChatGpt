<!DOCTYPE html>
<!--
  Data Viewer & Converter
  ----------------------
  This single‑file application implements the scaffold for a secure offline data
  viewer, editor and converter. It obeys the strict requirements defined in
  Promptmall_Data_Viewer_Converter_v3_0_Hardad.md. All scripts and styles are
  inlined to ensure offline functionality and to enable a strong Content
  Security Policy (CSP).  The application is intentionally modular: core
  features live behind tabs (Import, View, Edit, Convert, Export, QA) and
  progressively enhance with additional functionality in later phases.
  
  Security highlights:
  • CSP forbids external resources and eval. All code is inline and runs in
    strict mode.  No dynamic evaluation is used.
  • File parsing happens in a dedicated Web Worker where possible to keep the
    UI responsive and to limit the impact of malicious inputs. A hard limit of
    25 MB is enforced during import to mitigate zip‑bomb style attacks.
  • Converting to CSV prefixes cells starting with = + - or @ with a single
    apostrophe to prevent Excel injection.
  • HTML and Markdown rendering is sanitised to escape tags; no user generated
    HTML is inserted unescaped.
  • Undo/Redo history maintains up to 100 snapshots of the document.
  • Accessibility: the app exposes ARIA roles, keyboard navigation, high
    contrast/dyslexia modes and reduced motion toggles. The root <html> uses
    lang="sv" to reflect Swedish localisation.
  
  NOTE: This file represents the Phase 1 & 2 scaffold. Some conversion
  routines (YAML/XML/Markdown/HTML) are currently simplified and will be
  expanded in later phases.
-->
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Data Viewer &amp; Converter</title>
  <!-- Content Security Policy: restrict everything to self and blob for
       worker‑scripts.  Disallow eval() and external resources. -->
  <meta
    http-equiv="Content-Security-Policy"
    content="default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data:; object-src 'none'; worker-src blob:; connect-src 'none'; frame-src 'none'; base-uri 'none'; form-action 'none'; font-src 'self' data:;"/>
  <style>
    /* Base styles */
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background-color: #f9fafb;
      color: #111827;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark-mode {
      background-color: #111827;
      color: #f9fafb;
    }
    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1rem;
    }
    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }
    nav {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }
    nav button {
      flex: 1 1 auto;
      padding: 0.6rem 1rem;
      margin: 0.2rem;
      background-color: #e5e7eb;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    nav button.active {
      background-color: #2563eb;
      color: #ffffff;
    }
    .tab {
      display: none;
    }
    .tab.active {
      display: block;
    }
    /* View section */
    pre {
      white-space: pre-wrap;
      word-break: break-all;
      background-color: #f3f4f6;
      padding: 1rem;
      border-radius: 4px;
      overflow: auto;
      max-height: 60vh;
    }
    textarea {
      width: 100%;
      min-height: 200px;
      font-family: monospace;
      font-size: 0.9rem;
      padding: 0.5rem;
      margin-bottom: 0.5rem;
    }
    /* A11y toggles */
    .a11y-controls {
      margin-top: 1rem;
    }
    .a11y-controls label {
      margin-right: 1rem;
      cursor: pointer;
    }
    /* High contrast */
    body.high-contrast {
      background-color: #000000;
      color: #ffffff;
    }
    body.high-contrast nav button {
      background-color: #444444;
      color: #ffffff;
    }
    body.high-contrast nav button.active {
      background-color: #ffffff;
      color: #000000;
    }
    /* Dyslexia friendly font */
    body.dyslexia-font {
      font-family: "OpenDyslexic", system-ui, sans-serif;
    }
    /* Reduced motion */
    body.reduced-motion * {
      transition: none !important;
      animation: none !important;
    }
    /* Notification / warning box */
    .notification {
      background-color: #fef3c7;
      color: #92400e;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
      display: none;
    }
    .notification.show {
      display: block;
    }
    /* Accessible table for conversions */
    table {
      border-collapse: collapse;
      width: 100%;
    }
    th, td {
      padding: 0.4rem 0.6rem;
      border: 1px solid #d1d5db;
    }
    th {
      background-color: #e5e7eb;
      text-align: left;
    }
    /* History buttons */
    .history-controls button {
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Data Viewer &amp; Converter</h1>
    <nav aria-label="View navigation">
      <button id="tab-import" aria-controls="panel-import" class="active" role="tab">Importera</button>
      <button id="tab-view" aria-controls="panel-view" role="tab">Visa</button>
      <button id="tab-edit" aria-controls="panel-edit" role="tab">Redigera</button>
      <button id="tab-convert" aria-controls="panel-convert" role="tab">Konvertera</button>
      <button id="tab-export" aria-controls="panel-export" role="tab">Exportera</button>
      <button id="tab-validate" aria-controls="panel-validate" role="tab">Validera</button>
      <button id="tab-batch" aria-controls="panel-batch" role="tab">Batch</button>
      <button id="tab-qa" aria-controls="panel-qa" role="tab">QA</button>
    </nav>
    <div id="notification" class="notification" role="alert"></div>
    <!-- Import panel -->
    <div id="panel-import" class="tab active" role="tabpanel">
      <h2>Importera fil</h2>
      <p>
        Välj en fil (JSON, XML, YAML eller CSV). Filstorleken får inte överstiga 25 MB.
      </p>
      <input type="file" id="file-input" aria-label="Välj fil" />
    </div>
    <!-- View panel -->
    <div id="panel-view" class="tab" role="tabpanel">
      <h2>Förhandsgranskning</h2>
      <div id="view-container"></div>
    </div>
    <!-- Edit panel -->
    <div id="panel-edit" class="tab" role="tabpanel">
      <h2>Redigera data</h2>
      <textarea id="editor" aria-label="Redigera data"></textarea>
      <div class="history-controls">
        <button id="undo-btn" aria-label="Ångra">Ångra</button>
        <button id="redo-btn" aria-label="Gör om">Gör om</button>
      </div>
      <button id="apply-edit-btn" aria-label="Spara ändringar">Spara ändringar</button>
    </div>
    <!-- Convert panel -->
    <div id="panel-convert" class="tab" role="tabpanel">
      <h2>Konvertera data</h2>
      <p>Välj vilket format du vill konvertera till.</p>
      <select id="convert-target" aria-label="Välj målformat">
        <option value="json">JSON</option>
        <option value="xml">XML</option>
        <option value="yaml">YAML</option>
        <option value="csv">CSV</option>
        <option value="markdown">Markdown</option>
        <option value="html">HTML</option>
      </select>
      <button id="convert-btn" aria-label="Starta konvertering">Konvertera</button>
      <div id="convert-result"></div>
      <p id="convert-warn" style="color:#92400e;"></p>
    </div>
    <!-- Export panel -->
    <div id="panel-export" class="tab" role="tabpanel">
      <h2>Exportera</h2>
      <div class="toolbar">
        <button id="btnExportSingle" aria-label="Exportera som single-file HTML" class="btn primary">Single‑file HTML</button>
        <button id="btnExportPDF" aria-label="Exportera som PDF" class="btn">PDF</button>
      </div>
      <p class="meta">Single‑file HTML genererar en komplett fil med inbäddad state. PDF använder webbläsarens utskriftsdialog.</p>
    </div>

    <!-- Validate panel -->
    <div id="panel-validate" class="tab" role="tabpanel">
      <h2>Validera</h2>
      <p>Validera aktuell JSON mot ett schema (draft‑07 subset). Ange schema i fältet till vänster och klicka på Validera.</p>
      <div class="grid cols-2" style="display:flex; gap:1rem;">
        <div style="flex:1;">
          <label for="schema" class="meta">Schema (JSON)</label>
          <textarea id="schema" style="width:100%; min-height:220px; background:#f3f4f6; color:inherit; border:1px solid #d1d5db; border-radius:4px; font-family:monospace; padding:.5rem;" aria-label="JSON Schema editor">
{
  "type": "object",
  "required": [],
  "properties": {}
}
          </textarea>
          <div class="toolbar" style="margin-top:.5rem;">
            <button id="btnValidate" class="btn primary">Validera</button>
          </div>
        </div>
        <div style="flex:1;">
          <h4>Fel</h4>
          <ul id="validate-errors" class="meta" aria-live="polite" style="max-height:220px; overflow:auto;"></ul>
        </div>
      </div>
    </div>

    <!-- Batch panel -->
    <div id="panel-batch" class="tab" role="tabpanel">
      <h2>Batch‑konvertering</h2>
      <p class="meta">Välj dokument och ett målformat. Resultatet visas i textfältet nedan.</p>
      <div class="toolbar" style="margin-bottom:.5rem;">
        <select id="batch-target" aria-label="Målformat">
          <option value="json">JSON</option>
          <option value="xml">XML</option>
          <option value="yaml">YAML</option>
          <option value="csv">CSV</option>
          <option value="markdown">Markdown</option>
          <option value="html">HTML</option>
        </select>
        <button id="btnBatchRun" class="btn primary" aria-label="Kör batch">Kör batch</button>
      </div>
      <div id="batch-list" class="meta" style="border:1px solid #d1d5db; border-radius:4px; padding:.5rem; max-height:200px; overflow:auto;"></div>
      <h4>Batch‑resultat</h4>
      <pre id="batch-output" class="tree" style="background-color:#f3f4f6; border:1px solid #d1d5db; border-radius:4px; padding:.5rem; max-height:200px; overflow:auto;"></pre>
    </div>

    <!-- Command palette overlay -->
    <div id="cmdk" role="dialog" aria-modal="true" aria-label="Kommandopalett" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45); z-index:1000;">
      <div style="max-width:640px; margin:10vh auto; background:#ffffff; color:#111827; border:1px solid #d1d5db; border-radius:8px; padding:1rem;">
        <input id="cmdk-input" placeholder="Sök kommando…" aria-label="Sök kommando" style="width:100%; padding:.5rem .6rem; background:#f3f4f6; color:inherit; border:1px solid #d1d5db; border-radius:4px;" />
        <ul id="cmdk-list" style="margin:0.5rem 0 0; padding:0; list-style:none; max-height:240px; overflow:auto;"></ul>
      </div>
    </div>
    <!-- QA panel -->
    <div id="panel-qa" class="tab" role="tabpanel">
      <h2>QA / Test</h2>
      <p>Denna panel används för interna tester och kommer att utökas med automatiska tester i kommande faser.</p>
      <ul>
        <li>Importera filer och validera att <strong>zip‑bomb‑skyddet</strong> fungerar (max 25 MB).</li>
        <li>Testa att <strong>CSV‑injektion</strong> hanteras korrekt (apostrof prefix).</li>
        <li>Kontrollera <strong>Undo/Redo</strong> (100 snapshot som gräns).</li>
        <li>Verifiera att <strong>lossy‑policy</strong> varnar vid konvertering av inbäddade objekt till platt CSV.</li>
        <li>Bekräfta att <strong>Accessibility‑lägen</strong> (Hög kontrast, Dyslexi‑font, Reducerad rörelse) fungerar.</li>
      </ul>
    </div>
    <!-- Accessibility controls -->
    <div class="a11y-controls">
      <label><input type="checkbox" id="toggle-contrast" /> Hög kontrast</label>
      <label><input type="checkbox" id="toggle-dyslexia" /> Dyslexi‑font</label>
      <label><input type="checkbox" id="toggle-motion" /> Reducerad rörelse</label>
    </div>
  </div>
  <script>
    'use strict';
    // Application state
    let currentData = null;         // Parsed representation of the current document
    let currentFormat = null;       // Original format of imported data
    const history = [];             // History stack for undo/redo
    let historyIndex = -1;
    // Multi‑document support: an array of imported docs
    const docs = [];
    let currentDocIndex = -1;

    /**
     * Utility: escape HTML to prevent injection.
     * @param {string} str
     */
    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    /**
     * CSV injection protection: prefix values starting with =,+,-,@ with a single apostrophe.
     * @param {string} value
     */
    function protectCsv(value) {
      return (/^[=+\-@]/.test(value)) ? `'${value}` : value;
    }

    /**
     * Convert an object to CSV.
     * This function flattens nested objects by dot‑joining keys. Arrays are joined with
     * commas.  When nested structures are present, a warning is shown to the user.
     */
    function toCsv(objArray) {
      const rows = [];
      let warned = false;
      // Flatten each object
      const flatten = (obj, prefix = '', res = {}) => {
        for (const key in obj) {
          const value = obj[key];
          const newKey = prefix ? `${prefix}.${key}` : key;
          if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
            warned = true;
            flatten(value, newKey, res);
          } else {
            res[newKey] = Array.isArray(value) ? value.join(',') : value;
          }
        }
        return res;
      };
      const flatData = objArray.map(item => flatten(item));
      // Collect headers
      const headers = Array.from(new Set(flatData.reduce((acc, row) => acc.concat(Object.keys(row)), [])));
      rows.push(headers);
      for (const row of flatData) {
        rows.push(headers.map(header => {
          const val = row[header] !== undefined ? String(row[header]) : '';
          return protectCsv(val);
        }));
      }
      // Show warning if nested objects were flattened
      // Note: warnings om förlust vid CSV hanteras i diffLossCsv i konverteringsknappen.
      return rows.map(r => r.map(v => `"${v.replace(/"/g, '""')}"`).join(',')).join('\n');
    }

    /**
     * Räkna celler i CSV‑data som börjar med formelindikatörer (=, +, -, @).
     * @param {Array<Object>} rows
     * @returns {number}
     */
    function csvFormulaCount(rows) {
      let count = 0;
      for (const r of rows) {
        for (const key of Object.keys(r)) {
          const val = String(r[key] ?? '');
          if (/^[=+\-@]/.test(val)) count++;
        }
      }
      return count;
    }

    /**
     * Hitta förlustfyllda nyckelvägar när objekt konverteras till CSV. Återger
     * unika strängar som beskriver vägen till inbäddade objekt som plattas ut.
     * @param {any} data
     */
    function diffLossCsv(data) {
      const losses = [];
      const collect = (obj, path = []) => {
        if (Array.isArray(obj)) {
          obj.forEach((v, i) => collect(v, path.concat([`[${i}]`])));
        } else if (obj && typeof obj === 'object') {
          for (const k of Object.keys(obj)) {
            const v = obj[k];
            if (v && typeof v === 'object') {
              losses.push(path.concat([k]).join('.'));
              collect(v, path.concat([k]));
            }
          }
        }
      };
      collect(data);
      return [...new Set(losses)];
    }

    /**
     * Begränsa längden på en JSON/YAML‑presentation i förhandsvyn för att undvika
     * prestandaproblem. Om antalet rader överskrider maxLines returneras en
     * trunkerad sträng med ellipsis.
     * @param {string} str
     * @param {number} maxLines
     */
    function truncateLines(str, maxLines = 600) {
      const lines = str.split('\n');
      if (lines.length <= maxLines) return str;
      return lines.slice(0, maxLines).join('\n') + '\n... (trunkerad för snabb förhandsvisning)';
    }

    /**
     * Convert CSV string to JSON array. Simple implementation supporting comma
     * separated values with quoted fields.
     */
    function csvToJson(csv) {
      const lines = csv.trim().split(/\r?\n/);
      const headers = lines.shift().split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/).map(h => h.replace(/\"/g, '').replace(/^\s*"|"\s*$/g, ''));
      const data = [];
      for (const line of lines) {
        if (!line) continue;
        const cells = line.split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/).map(c => c.replace(/\"/g, '').replace(/^\s*"|"\s*$/g, ''));
        const obj = {};
        headers.forEach((h, i) => {
          obj[h] = cells[i] || '';
        });
        data.push(obj);
      }
      return data;
    }

    /**
     * Convert a simple JSON object to XML. This implementation is naive and does
     * not support attributes or special types. Arrays become repeated child
     * elements. Objects map to nested tags.
     */
    function jsonToXml(obj, rootName = 'root') {
      const encode = (text) => escapeHtml(text);
      const build = (node, name) => {
        if (Array.isArray(node)) {
          return node.map(item => build(item, name)).join('');
        } else if (typeof node === 'object' && node !== null) {
          const children = Object.entries(node).map(([k, v]) => build(v, k)).join('');
          return `<${name}>${children}</${name}>`;
        } else {
          return `<${name}>${encode(String(node))}</${name}>`;
        }
      };
      return `<?xml version="1.0" encoding="UTF-8"?>\n` + build(obj, rootName);
    }

    /**
     * Convert a naive XML string to JSON. This parser supports simple nested
     * elements with no attributes. It does not handle namespaces or mixed
     * content. If parsing fails, an error is thrown.
     */
    function xmlToJson(xml) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xml, 'application/xml');
      const parserError = xmlDoc.getElementsByTagName('parsererror')[0];
      if (parserError) {
        throw new Error('XML kunde inte tolkas');
      }
      const convert = (node) => {
        const obj = {};
        // element nodes
        if (node.children.length) {
          for (const child of node.children) {
            const key = child.nodeName;
            const value = convert(child);
            if (obj[key] !== undefined) {
              // convert to array if multiple children with same name
              if (!Array.isArray(obj[key])) obj[key] = [obj[key]];
              obj[key].push(value);
            } else {
              obj[key] = value;
            }
          }
          return obj;
        } else {
          return node.textContent;
        }
      };
      // Root element
      const root = xmlDoc.documentElement;
      const result = {};
      result[root.nodeName] = convert(root);
      return result;
    }

    /**
     * Convert a naive YAML string to JSON. This is a very simple parser that
     * supports only basic key: value pairs and indentation for nested objects.
     * It is not a full YAML spec implementation. Arrays should be prefaced
     * with "- " at the same indentation level. Strings containing colons
     * should be quoted. Use this parser for demonstration only.
     */
    function yamlToJson(yaml) {
      const lines = yaml.replace(/\t/g, '    ').split(/\r?\n/);
      const stack = [{}];
      const indentStack = [0];
      let currentObj = stack[0];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line.trim() || /^\s*#/.test(line)) continue; // skip empty or comment
        const indentMatch = line.match(/^(\s*)/);
        const indent = indentMatch ? indentMatch[1].length : 0;
        const trimmed = line.trim();
        // adjust stack based on indent
        while (indent < indentStack[indentStack.length - 1]) {
          stack.pop();
          indentStack.pop();
        }
        if (trimmed.startsWith('- ')) {
          // array item
          const key = '__array';
          const valuePart = trimmed.substring(2).trim();
          const value = parseYamlValue(valuePart);
          if (!Array.isArray(stack[stack.length - 1][key])) {
            stack[stack.length - 1][key] = [];
          }
          if (typeof value === 'object' && value !== null) {
            // create new nested object
            const newObj = {};
            stack[stack.length - 1][key].push(newObj);
            stack.push(newObj);
            indentStack.push(indent + 2);
          } else {
            stack[stack.length - 1][key].push(value);
          }
          continue;
        }
        const kv = trimmed.split(/:(.+)/);
        const key = kv[0].trim();
        const valuePart = kv[1] !== undefined ? kv[1].trim() : '';
        const value = parseYamlValue(valuePart);
        if (typeof value === 'object' && value !== null) {
          // new nested object
          stack[stack.length - 1][key] = {};
          stack.push(stack[stack.length - 1][key]);
          indentStack.push(indent);
        } else {
          stack[stack.length - 1][key] = value;
        }
      }
      return stack[0];
      // Helper to parse primitive values
      function parseYamlValue(val) {
        if (val === '' || val === undefined) return {};
        if (val === 'true') return true;
        if (val === 'false') return false;
        if (!isNaN(Number(val))) return Number(val);
        if (/^['"].*['"]$/.test(val)) return val.slice(1, -1);
        return val;
      }
    }

    /**
     * Convert JSON to a simple YAML string. This function outputs YAML with
     * 2‑space indentation. Arrays become dash‑prefixed lines. Only string,
     * number, boolean and null values are supported. Nested objects are
     * indented recursively. This is not a full YAML generator but works for
     * simple structures.
     */
    function jsonToYaml(obj, indent = 0) {
      const spaces = '  '.repeat(indent);
      if (Array.isArray(obj)) {
        return obj
          .map(item => spaces + '- ' + jsonToYaml(item, indent + 1).trim())
          .join('\n');
      } else if (typeof obj === 'object' && obj !== null) {
        return Object.entries(obj)
          .map(([k, v]) => {
            if (typeof v === 'object' && v !== null) {
              return `${spaces}${k}:\n${jsonToYaml(v, indent + 1)}`;
            } else {
              return `${spaces}${k}: ${String(v)}`;
            }
          })
          .join('\n');
      } else {
        return String(obj);
      }
    }

    /**
     * Convert JSON to Markdown. For demonstration this simply pretty‑prints
     * JSON inside a fenced code block. A more sophisticated converter could
     * generate Markdown tables or bullet lists.
     */
    function jsonToMarkdown(data) {
      return '```json\n' + JSON.stringify(data, null, 2) + '\n```';
    }

    /**
     * Convert Markdown to JSON. This parser extracts JSON from a fenced
     * code block if present. Otherwise returns plain text as a string.
     */
    function markdownToJson(md) {
      const match = md.match(/```json\n([\s\S]*?)\n```/);
      if (match) {
        try {
          return JSON.parse(match[1]);
        } catch (e) {
          throw new Error('JSON‑koden i Markdown kunde inte tolkas');
        }
      }
      return { text: md };
    }

    /**
     * Update the view panel with the currentData in its original format and
     * pretty print JSON. It escapes HTML to avoid XSS.
     */
    function updateView() {
      const viewContainer = document.getElementById('view-container');
      if (!currentData) {
        viewContainer.innerHTML = '<p>Ingen data importerad ännu.</p>';
        return;
      }
      let content = '';
      if (currentFormat === 'json') {
        // Generera prettified JSON och trunkera vid många rader
        const jsonStr = JSON.stringify(currentData, null, 2);
        const truncated = truncateLines(jsonStr);
        content = '<pre>' + escapeHtml(truncated) + '</pre>';
      } else if (currentFormat === 'xml') {
        const xmlStr = jsonToXml(currentData, Object.keys(currentData)[0] || 'root');
        const truncated = truncateLines(xmlStr);
        content = '<pre>' + escapeHtml(truncated) + '</pre>';
      } else if (currentFormat === 'yaml') {
        const yamlStr = jsonToYaml(currentData);
        const truncated = truncateLines(yamlStr);
        content = '<pre>' + escapeHtml(truncated) + '</pre>';
      } else if (currentFormat === 'csv') {
        // Represent CSV as table
        const rows = currentData;
        if (rows.length === 0) {
          content = '<p>Tom CSV.</p>';
        } else {
          let table = '<table><thead><tr>';
          Object.keys(rows[0]).forEach(h => {
            table += '<th>' + escapeHtml(h) + '</th>';
          });
          table += '</tr></thead><tbody>';
          rows.forEach(r => {
            table += '<tr>';
            Object.keys(rows[0]).forEach(h => {
              table += '<td>' + escapeHtml(String(r[h] ?? '')) + '</td>';
            });
            table += '</tr>';
          });
          table += '</tbody></table>';
          content = table;
        }
      } else {
        content = '<pre>' + escapeHtml(JSON.stringify(currentData, null, 2)) + '</pre>';
      }
      viewContainer.innerHTML = content;
    }

    /**
     * Switch active tab. Called when user clicks nav buttons.
     */
    function switchTab(targetId) {
      document.querySelectorAll('nav button').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab').forEach(panel => panel.classList.remove('active'));
      document.getElementById('tab-' + targetId).classList.add('active');
      document.getElementById('panel-' + targetId).classList.add('active');
    }

    /**
     * Show a notification message. It will persist until next call or manual hide.
     */
    function showNotification(msg) {
      const note = document.getElementById('notification');
      note.textContent = msg;
      note.classList.add('show');
    }
    function hideNotification() {
      const note = document.getElementById('notification');
      note.classList.remove('show');
    }

    /**
     * Set a status message. Currently används showNotification för att visa meddelanden.
     * @param {string} msg
     */
    function setStatus(msg) {
      showNotification(msg);
    }

    /**
     * Push the current state into history for undo/redo. History is capped
     * at 100 entries.
     */
    function pushHistory(data, format) {
      // Truncate any redo history
      history.splice(historyIndex + 1);
      history.push({ data: JSON.parse(JSON.stringify(data)), format });
      if (history.length > 100) history.shift();
      historyIndex = history.length - 1;
    }

    /**
     * Undo and redo operations
     */
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const { data, format } = history[historyIndex];
        currentData = JSON.parse(JSON.stringify(data));
        currentFormat = format;
        hideNotification();
        updateView();
        document.getElementById('editor').value = JSON.stringify(currentData, null, 2);
      }
    }
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        const { data, format } = history[historyIndex];
        currentData = JSON.parse(JSON.stringify(data));
        currentFormat = format;
        hideNotification();
        updateView();
        document.getElementById('editor').value = JSON.stringify(currentData, null, 2);
      }
    }

    /**
     * Detect file type based on extension and/or content. Returns one of
     * json/xml/yaml/csv/markdown/html. Throws on unsupported types.
     */
    function detectFormat(name, content) {
      const extMatch = name ? name.split('.').pop().toLowerCase() : '';
      if (extMatch === 'json') return 'json';
      if (extMatch === 'xml') return 'xml';
      if (extMatch === 'yaml' || extMatch === 'yml') return 'yaml';
      if (extMatch === 'csv') return 'csv';
      if (extMatch === 'md' || extMatch === 'markdown') return 'markdown';
      if (extMatch === 'html' || extMatch === 'htm') return 'html';
      // Fallback: sniff content
      const trimmed = content.trim();
      if (/^<\?xml/.test(trimmed) || /<[^>]+>/.test(trimmed)) return 'xml';
      if (/^[\{\[]/.test(trimmed)) return 'json';
      if (/^---/.test(trimmed) || /:\s/.test(trimmed)) return 'yaml';
      if (trimmed.includes(',')) return 'csv';
      return 'json';
    }

    /**
     * Parse imported file content to JavaScript object. Updates currentData
     * and currentFormat, pushes history and updates UI. Throws on error.
     */
    function parseContent(name, text) {
      const format = detectFormat(name, text);
      let data;
      if (format === 'json') {
        data = JSON.parse(text);
      } else if (format === 'xml') {
        data = xmlToJson(text);
      } else if (format === 'yaml') {
        data = yamlToJson(text);
      } else if (format === 'csv') {
        data = csvToJson(text);
        // Scanna CSV för formelceller
        const sus = csvFormulaCount(data);
        if (sus > 0) {
          showNotification('Importerad CSV med ' + sus + ' potentiella formelceller – injektionsskydd aktivt.');
        }
      } else if (format === 'markdown') {
        data = markdownToJson(text);
      } else if (format === 'html') {
        // treat HTML as plain text inside object
        data = { html: text };
      } else {
        throw new Error('Okänt filformat');
      }
      // Create document entry and push into docs array
      const doc = { name: name || ('doc-' + (docs.length + 1)), data, type: format };
      docs.push(doc);
      currentDocIndex = docs.length - 1;
      currentData = data;
      currentFormat = format;
      pushHistory(data, format);
      updateView();
      // Update editor to show current doc
      document.getElementById('editor').value = JSON.stringify(currentData, null, 2);
    }

    // Event listeners
    document.getElementById('file-input').addEventListener('change', (e) => {
      hideNotification();
      const file = e.target.files[0];
      if (!file) return;
      if (file.size > 25 * 1024 * 1024) {
        showNotification('Filen är för stor. Max 25 MB.');
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        try {
          parseContent(file.name, reader.result);
          // uppdatera batchlistan när en ny fil importerats
          if (document.getElementById('panel-batch').classList.contains('active')) {
            renderBatchList();
          }
          switchTab('view');
        } catch (err) {
          showNotification('Kunde inte importera fil: ' + err.message);
        }
      };
      reader.onerror = () => showNotification('Fel vid läsning av fil');
      reader.readAsText(file);
    });

    // Navigation buttons
    document.getElementById('tab-import').addEventListener('click', () => switchTab('import'));
    document.getElementById('tab-view').addEventListener('click', () => switchTab('view'));
    document.getElementById('tab-edit').addEventListener('click', () => switchTab('edit'));
    document.getElementById('tab-convert').addEventListener('click', () => switchTab('convert'));
    document.getElementById('tab-export').addEventListener('click', () => switchTab('export'));
    document.getElementById('tab-validate').addEventListener('click', () => {
      switchTab('validate');
    });
    document.getElementById('tab-batch').addEventListener('click', () => {
      switchTab('batch');
      renderBatchList();
    });
    document.getElementById('tab-qa').addEventListener('click', () => switchTab('qa'));

    // Undo/Redo buttons
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('redo-btn').addEventListener('click', redo);
    document.getElementById('apply-edit-btn').addEventListener('click', () => {
      hideNotification();
      try {
        const updated = JSON.parse(document.getElementById('editor').value);
        currentData = updated;
        currentFormat = 'json';
        pushHistory(currentData, currentFormat);
        updateView();
      } catch (err) {
        showNotification('Fel i JSON: ' + err.message);
      }
    });

    // Conversion button
    document.getElementById('convert-btn').addEventListener('click', () => {
      hideNotification();
      if (!currentData) {
        showNotification('Ingen data att konvertera');
        return;
      }
      const target = document.getElementById('convert-target').value;
      let result = '';
      try {
        const warnEl = document.getElementById('convert-warn');
        warnEl.textContent = '';
        if (target === currentFormat) {
          result = JSON.stringify(currentData, null, 2);
        } else if (target === 'json') {
          result = JSON.stringify(currentData, null, 2);
        } else if (target === 'xml') {
          result = jsonToXml(currentData, 'root');
        } else if (target === 'yaml') {
          result = jsonToYaml(currentData);
        } else if (target === 'csv') {
          if (!Array.isArray(currentData)) {
            showNotification('CSV‑export kräver en lista av objekt.');
            return;
          }
          // Varna om förlust vid CSV genom att visa diffLossCsv
          const lost = diffLossCsv(currentData);
          if (lost.length) {
            const preview = lost.slice(0, 5).join(', ');
            warnEl.textContent = 'Förlust: ' + lost.length + ' fält/nyckelvägar plattas ut (t.ex. ' + preview + (lost.length > 5 ? ' ...' : '') + ')';
          }
          result = toCsv(currentData);
        } else if (target === 'markdown') {
          result = jsonToMarkdown(currentData);
        } else if (target === 'html') {
          // wrap JSON in <pre> for simple HTML export
          result = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Export</title></head><body><pre>' + escapeHtml(JSON.stringify(currentData, null, 2)) + '</pre></body></html>';
        }
        document.getElementById('convert-result').innerHTML = '<pre>' + escapeHtml(result) + '</pre>';
      } catch (err) {
        showNotification('Fel vid konvertering: ' + err.message);
      }
    });

    // Export buttons
    function exportFile(format) {
      hideNotification();
      if (!currentData) {
        showNotification('Ingen data att exportera');
        return;
      }
      let content = '';
      let ext = format;
      try {
        if (format === 'json') {
          content = JSON.stringify(currentData, null, 2);
        } else if (format === 'xml') {
          content = jsonToXml(currentData, 'root');
        } else if (format === 'yaml') {
          content = jsonToYaml(currentData);
        } else if (format === 'csv') {
          if (!Array.isArray(currentData)) {
            showNotification('CSV‑export kräver en lista av objekt.');
            return;
          }
          content = toCsv(currentData);
        } else if (format === 'markdown') {
          content = jsonToMarkdown(currentData);
          ext = 'md';
        } else if (format === 'html') {
          content = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Export</title></head><body><pre>' + escapeHtml(JSON.stringify(currentData, null, 2)) + '</pre></body></html>';
        }
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'export.' + ext;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      } catch (err) {
        showNotification('Fel vid export: ' + err.message);
      }
    }

    // New export functions for single-file HTML and PDF
    function serializeSingleFile() {
      // Build an HTML containing all docs in docs array with embedded JSON state
      const state = { docs: docs.map(d => ({ name: d.name, data: d.data, type: d.type })) };
      const stateJson = JSON.stringify(state);
      const html = `<!DOCTYPE html><html lang="sv"><head><meta charset="utf-8">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; script-src 'self' 'unsafe-inline'">
<title>Export</title>
<style>body{font-family:system-ui,-apple-system,sans-serif;padding:1rem;}pre{white-space:pre-wrap;border:1px solid #d1d5db;border-radius:4px;padding:.5rem;}</style>
</head><body>
<h1>Data Export</h1>
<p>Detta är en export av dina importerade dokument.</p>
<script id="snapshot" type="application/json">${stateJson.replace(/</g, '\\u003c')}</script>
<script>const state = JSON.parse(document.getElementById('snapshot').textContent);
const heading = document.createElement('h2');
heading.textContent = 'Dokument';
document.body.appendChild(heading);
const pre = document.createElement('pre');
pre.textContent = JSON.stringify(state.docs, null, 2);
document.body.appendChild(pre);
</script>
</body></html>`;
      return new Blob([html], { type: 'text/html;charset=utf-8' });
    }
    function openPrintView() {
      const w = window.open('', '_blank');
      const docExport = w.document;
      docExport.open();
      const previewDocs = docs.slice(0, 3).map(d => ({ name: d.name, type: d.type, data: d.data }));
      docExport.write(`<!DOCTYPE html><html lang="sv"><head><meta charset="utf-8">
<title>PDF Export</title>
<style>@page{margin:16mm;}body{font-family:system-ui,-apple-system,sans-serif;padding:1rem;}pre{white-space:pre-wrap;border:1px solid #d1d5db;border-radius:4px;padding:.5rem;}</style>
</head><body>
<h1>PDF Export</h1>
<p>Nedan visas de första tre dokumenten. Använd webbläsarens utskriftsdialog för att spara som PDF.</p>
<pre>${escapeHtml(JSON.stringify(previewDocs, null, 2)).slice(0,20000)}</pre>
<script>window.onload = () => setTimeout(() => window.print(), 100);</script>
</body></html>`);
      docExport.close();
    }

    // Attach export button events
    const btnExportSingle = document.getElementById('btnExportSingle');
    if (btnExportSingle) {
      btnExportSingle.addEventListener('click', () => {
        const blob = serializeSingleFile();
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'export_single_file.html';
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 1000);
      });
    }
    const btnExportPdf = document.getElementById('btnExportPDF');
    if (btnExportPdf) {
      btnExportPdf.addEventListener('click', () => {
        openPrintView();
      });
    }

    // Accessibility toggles
    document.getElementById('toggle-contrast').addEventListener('change', (e) => {
      document.body.classList.toggle('high-contrast', e.target.checked);
    });
    document.getElementById('toggle-dyslexia').addEventListener('change', (e) => {
      document.body.classList.toggle('dyslexia-font', e.target.checked);
    });
    document.getElementById('toggle-motion').addEventListener('change', (e) => {
      document.body.classList.toggle('reduced-motion', e.target.checked);
    });

    // Persist accessibility preferences in localStorage
    ['toggle-contrast','toggle-dyslexia','toggle-motion'].forEach(id => {
      const checkbox = document.getElementById(id);
      const stored = localStorage.getItem(id);
      if (stored === 'true') {
        checkbox.checked = true;
        checkbox.dispatchEvent(new Event('change'));
      }
      checkbox.addEventListener('change', () => {
        localStorage.setItem(id, checkbox.checked);
      });
    });

    /**
     * Enkel JSON Schema-validerare (subset). Stödjer type, required, properties,
     * items, minLength, maxLength, minimum och maximum.
     * @param {any} data
     * @param {object} schema
     * @returns {string[]} Lista av felmeddelanden
     */
    function validateJsonAgainstSchema(data, schema) {
      const errors = [];
      function typeOf(x) {
        if (Array.isArray(x)) return 'array';
        if (x === null) return 'null';
        return typeof x;
      }
      function check(node, sch, path) {
        if (!sch || typeof sch !== 'object') return;
        if (sch.type) {
          const t = Array.isArray(sch.type) ? sch.type : [sch.type];
          const ok = t.includes(typeOf(node));
          if (!ok) errors.push(`${path || 'root'}: typ ${typeOf(node)} != ${t.join('|')}`);
        }
        if (sch.minLength != null && typeof node === 'string' && node.length < sch.minLength) errors.push(`${path || 'root'}: minLength ${sch.minLength}`);
        if (sch.maxLength != null && typeof node === 'string' && node.length > sch.maxLength) errors.push(`${path || 'root'}: maxLength ${sch.maxLength}`);
        if (sch.minimum != null && typeof node === 'number' && node < sch.minimum) errors.push(`${path || 'root'}: minimum ${sch.minimum}`);
        if (sch.maximum != null && typeof node === 'number' && node > sch.maximum) errors.push(`${path || 'root'}: maximum ${sch.maximum}`);
        if (sch.type === 'object' && sch.properties && node && typeof node === 'object' && !Array.isArray(node)) {
          if (Array.isArray(sch.required)) {
            for (const r of sch.required) if (!(r in node)) errors.push(`${path || 'root'}: saknar obligatoriskt fält "${r}"`);
          }
          for (const key of Object.keys(node)) {
            if (sch.properties[key]) check(node[key], sch.properties[key], path ? `${path}.${key}` : key);
          }
        }
        if (sch.type === 'array' && sch.items && Array.isArray(node)) {
          for (let i = 0; i < node.length; i++) check(node[i], sch.items, `${path || 'root'}[${i}]`);
        }
      }
      check(data, schema, '');
      return errors;
    }
    // Event: Validate button
    const btnValidate = document.getElementById('btnValidate');
    if (btnValidate) {
      btnValidate.addEventListener('click', () => {
        const ul = document.getElementById('validate-errors');
        ul.innerHTML = '';
        if (currentData == null) {
          ul.innerHTML = '<li>Inget dokument laddat.</li>';
          return;
        }
        let schema;
        try {
          schema = JSON.parse(document.getElementById('schema').value);
        } catch (e) {
          ul.innerHTML = `<li>Ogiltigt schema: ${escapeHtml(e.message)}</li>`;
          return;
        }
        const errs = validateJsonAgainstSchema(currentData, schema);
        if (!errs.length) {
          ul.innerHTML = '<li>✔ Inga fel</li>';
        } else {
          ul.innerHTML = errs.map(err => `<li>${escapeHtml(err)}</li>`).join('');
        }
      });
    }

    /**
     * Batch-lista: generera checkboxar för varje importerat dokument
     */
    function renderBatchList() {
      const box = document.getElementById('batch-list');
      if (!box) return;
      if (docs.length === 0) {
        box.innerHTML = '<p>Inga dokument importerade.</p>';
        return;
      }
      box.innerHTML = docs.map((d, i) => {
        return `<label style="display:flex; align-items:center; gap:.5rem; padding:.25rem 0;">
          <input type="checkbox" data-doc-index="${i}" checked />
          <span style="font-weight:bold;">${i + 1}</span>
          <span>${escapeHtml(d.name)}</span>
          <span class="meta">(${escapeHtml(d.type)})</span>
        </label>`;
      }).join('');
    }
    // Batch run
    const btnBatchRun = document.getElementById('btnBatchRun');
    if (btnBatchRun) {
      btnBatchRun.addEventListener('click', () => {
        const sel = Array.from(document.querySelectorAll('#batch-list input[type="checkbox"]:checked'))
          .map(cb => parseInt(cb.getAttribute('data-doc-index'), 10));
        const target = document.getElementById('batch-target').value;
        const out = [];
        let lossyCount = 0;
        const t0 = performance.now();
        sel.forEach(idx => {
          const doc = docs[idx];
          let txt = '', warn = '';
          if (!doc) return;
          const data = doc.data;
          if (target === 'json') {
            txt = JSON.stringify(data, null, 2);
          } else if (target === 'xml') {
            txt = jsonToXml(data, 'root');
          } else if (target === 'yaml') {
            txt = jsonToYaml(data);
          } else if (target === 'csv') {
            if (!Array.isArray(data)) {
              txt = `// ${doc.name} är inte en lista av objekt, hoppar över.`;
            } else {
              const lost = diffLossCsv(data);
              if (lost.length) lossyCount += lost.length;
              txt = toCsv(data);
            }
          } else if (target === 'markdown') {
            txt = jsonToMarkdown(data);
          } else if (target === 'html') {
            txt = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Export</title></head><body><pre>' + escapeHtml(JSON.stringify(data, null, 2)) + '</pre></body></html>';
          }
          out.push(`----- ${doc.name}${warn}\n${txt}\n`);
        });
        const t1 = performance.now();
        const outputEl = document.getElementById('batch-output');
        if (outputEl) outputEl.textContent = out.join('\n');
        setStatus('Batch klar på ' + (t1 - t0).toFixed(1) + ' ms. Förlustnycklar: ' + lossyCount + '.');
      });
    }

    /**
     * Kommandopalett (Ctrl+K)
     */
    const CMDK = {
      open: false,
      cmds: [
        { label: 'Importera', run: () => document.getElementById('file-input').click() },
        { label: 'Snapshot (inte implementerat)', run: () => {} },
        { label: 'Ångra', run: () => undo() },
        { label: 'Gör om', run: () => redo() },
        { label: 'Konvertera → CSV', run: () => {
            document.getElementById('convert-target').value = 'csv';
            document.getElementById('convert-btn').click();
            switchTab('convert');
          } },
        { label: 'Validera', run: () => { switchTab('validate'); } },
        { label: 'Export → Single-file', run: () => {
            const btn = document.getElementById('btnExportSingle'); if (btn) btn.click();
          } },
        { label: 'Export → PDF', run: () => {
            const btn = document.getElementById('btnExportPDF'); if (btn) btn.click();
          } },
      ]
    };
    const cmdkEl = document.getElementById('cmdk');
    const cmdkInput = document.getElementById('cmdk-input');
    const cmdkList = document.getElementById('cmdk-list');

    function openCmdk() {
      CMDK.open = true;
      cmdkEl.style.display = 'block';
      cmdkInput.value = '';
      renderCmdk('');
      cmdkInput.focus();
    }
    function closeCmdk() {
      CMDK.open = false;
      cmdkEl.style.display = 'none';
    }
    function renderCmdk(q) {
      const hits = CMDK.cmds.filter(c => c.label.toLowerCase().includes(q.toLowerCase()));
      cmdkList.innerHTML = hits.map((c, i) => `<li style="padding:.4rem .6rem; border:1px solid #d1d5db; border-radius:4px; margin:.25rem 0; cursor:pointer;" data-idx="${i}">${escapeHtml(c.label)}</li>`).join('');
      Array.from(cmdkList.children).forEach(li => {
        li.addEventListener('click', () => {
          const idx = parseInt(li.getAttribute('data-idx'), 10);
          hits[idx].run(); closeCmdk();
        });
      });
    }
    if (cmdkInput) {
      cmdkInput.addEventListener('input', () => renderCmdk(cmdkInput.value));
    }
    document.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      const isCmdk = (e.ctrlKey && key === 'k');
      if (isCmdk) {
        e.preventDefault();
        CMDK.open ? closeCmdk() : openCmdk();
      }
      if (CMDK.open && key === 'escape') {
        e.preventDefault();
        closeCmdk();
      }
    });
  </script>
</body>
</html>
